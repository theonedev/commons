package io.onedev.commons.utils.command;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import javax.annotation.Nullable;

import io.onedev.commons.utils.ExceptionUtils;

public class ProcessStreamPumper {

    private static final int BUFFER_SIZE = 64*1024;
    
    private static final ExecutorService EXECUTOR = Executors.newCachedThreadPool();
    
    private final Future<?> stdoutPumper;

    private final Future<?> stderrPumper;
    
    private final Future<?> stdinPumper;

    private final OutputStream stdout;
    
    private final OutputStream stderr;
    
    public ProcessStreamPumper(Process process, @Nullable OutputStream stdout, 
    		@Nullable OutputStream stderr, @Nullable InputStream stdin) {
        this.stdout = stdout;
        this.stderr = stderr;
        
        stdoutPumper = createPump(process.getInputStream(), stdout, true, false);
        stderrPumper = createPump(process.getErrorStream(), stderr, true, false);
        
        if (stdin != null) {
            stdinPumper = createPump(stdin, process.getOutputStream(), false, true);
        } else {
        	stdinPumper = null;
        	try {
				process.getOutputStream().close();
			} catch (IOException e) {
			}
        }
    }
    
    public void waitFor() {
    	while (!stdoutPumper.isDone() || !stderrPumper.isDone() || 
    			(stdinPumper != null && !stdinPumper.isDone())) {
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
			}
    	}

    	try {
        	// call get() to re-throw possible exception generated by pumper 
			stdoutPumper.get();
			stderrPumper.get();
			if (stdinPumper != null)
				stdinPumper.get();
			
	    	if (stdout != null)
				stdout.flush();
	    	if (stderr != null) 
	    		stderr.flush();
		} catch (InterruptedException | ExecutionException | IOException e) {
			throw ExceptionUtils.unchecked(e);
		}

    }

    private Future<?> createPump(final InputStream input, @Nullable final OutputStream output, 
    		final boolean closeInputWhenExhausted, final boolean closeOutputWhenExhausted) {
    	
    	return EXECUTOR.submit(new Runnable() {

			public void run() {
		        byte[] buf = new byte[BUFFER_SIZE];
		
		        try {
			        int length;
		            while ((length = input.read(buf)) > 0) {
		            	if (output != null)
		            		output.write(buf, 0, length);
		            }
		        } catch (IOException e) {
		        	throw new RuntimeException(e);
				} finally {
		        	try {
						while (input.read(buf) > 0);
					} catch (IOException e) {
					}
		            if (closeInputWhenExhausted) { 
		            	try {
							input.close();
						} catch (IOException e) {
						}
		            }
		        	if (output != null && closeOutputWhenExhausted) {
						try {
							output.close();
						} catch (IOException e) {
						}
		        	}
		        }
			}
    		
    	});
    }

}
