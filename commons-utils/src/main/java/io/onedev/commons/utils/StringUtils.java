package io.onedev.commons.utils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.StringTokenizer;
import java.util.regex.Pattern;

import org.jspecify.annotations.Nullable;

import com.google.common.base.Splitter;

public class StringUtils extends org.apache.commons.lang3.StringUtils {

	private static final Pattern ESCAPE_PATTERN = Pattern.compile("\\\\(.)");
	
	public static String trimStart(String str) {
		return StringUtils.stripStart(str, " \r\n\t");
	}

	public static String trimEnd(String str) {
		return StringUtils.stripEnd(str, " \r\n\t");
	}
	
	@Nullable
    public static String join(@Nullable Collection<String> strings) {
    	if (strings != null && !strings.isEmpty())
    		return join(strings, ", ");
    	else
    		return null;
    }
    
	/**
	 * Remove UTF BOM marker which might exists in some source code. UTF standard does not allow this marker and we 
	 * should remove it before doing something such as parsing source with ANTLR
	 */
	public static String removeBOM(String str) {
		return str.replace("\uFEFF", "");		
	}
	
	/**
	 * Parse specified string into tokens. Content surrounded with &quot; character
	 * is considered as a single token. For example: echo "hello world" will be parsed 
	 * into two tokens, respectively [echo], and [hello world]. The quote character 
	 * itself can be quoted and escaped in order to return as ordinary character. For 
	 * example: echo "hello \" world" will be parsed into two tokens: [echo] and 
	 * [hello " world].
	 * @param string
	 * @return
	 */
    public static String[] parseQuoteTokens(String string) {
		List<String> result = new ArrayList<>();
		StringBuilder currentField = new StringBuilder();
		boolean inQuotes = false;
		boolean escaping = false;

		for (char c : string.toCharArray()) {
			if (escaping) {
				currentField.append(c);
				escaping = false;
			} else if (c == '\\') {
				escaping = true;
			} else if (c == '"') {
				inQuotes = !inQuotes;
			} else if (c == ' ' && !inQuotes) {
				if (currentField.length() > 0) {
					result.add(currentField.toString());
					currentField.setLength(0);
				}
			} else {
				currentField.append(c);
			}
		}

		if (currentField.length() > 0)
			result.add(currentField.toString());

		return result.toArray(new String[0]);
	}

    /**
     * Tokenize the given String into a String array via a StringTokenizer.
     * Trims tokens and omits empty tokens.
     * <p>The given delimiters string is supposed to consist of any number of
     * delimiter characters. Each of those characters can be used to separate
     * tokens. A delimiter is always a single character; for multi-character
     * delimiters, consider using <code>delimitedListToStringArray</code>
     * <p/>
     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.
     *
     * @param str        the String to tokenize
     * @param delimiters the delimiter characters, assembled as String
     *                   (each of those characters is individually considered as delimiter).
     * @return an array of the tokens
     * @see java.util.StringTokenizer
     * @see java.lang.String#trim()
     */
    public static String[] tokenizeToStringArray(String str, String delimiters) {
        return tokenizeToStringArray(str, delimiters, true, true);
    }

    /**
     * Tokenize the given String into a String array via a StringTokenizer.
     * <p>The given delimiters string is supposed to consist of any number of
     * delimiter characters. Each of those characters can be used to separate
     * tokens. A delimiter is always a single character; for multi-character
     * delimiters, consider using <code>delimitedListToStringArray</code>
     * <p/>
     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.
     *
     * @param str               the String to tokenize
     * @param delimiters        the delimiter characters, assembled as String
     *                          (each of those characters is individually considered as delimiter)
     * @param trimTokens        trim the tokens via String's <code>trim</code>
     * @param ignoreEmptyTokens omit empty tokens from the result array
     *                          (only applies to tokens that are empty after trimming; StringTokenizer
     *                          will not consider subsequent delimiters as token in the first place).
     * @return an array of the tokens (<code>null</code> if the input String
     *         was <code>null</code>)
     * @see java.util.StringTokenizer
     * @see java.lang.String#trim()
     */
    public static String[] tokenizeToStringArray(
            String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {

        if (str == null) {
            return null;
        }
        StringTokenizer st = new StringTokenizer(str, delimiters);
        List<String> tokens = new ArrayList<String>();
        while (st.hasMoreTokens()) {
            String token = st.nextToken();
            if (trimTokens) {
                token = token.trim();
            }
            if (!ignoreEmptyTokens || token.length() > 0) {
                tokens.add(token);
            }
        }
        return toStringArray(tokens);
    }

    /**
     * Copy the given Collection into a String array.
     * The Collection must contain String elements only.
     * <p/>
     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.
     *
     * @param collection the Collection to copy
     * @return the String array (<code>null</code> if the passed-in
     *         Collection was <code>null</code>)
     */
    public static String[] toStringArray(Collection<?> collection) {
        if (collection == null) {
            return null;
        }
        return collection.toArray(new String[collection.size()]);
    }

    private static final String SINGLE_QUOTE = "\'";
    private static final String DOUBLE_QUOTE = "\"";
    /**
     * Put quotes around the given String if necessary.
     * <p>
     * If the argument doesn't include spaces or quotes, return it as is. If it
     * contains double quotes, use single quotes - else surround the argument by
     * double quotes.
     * </p>
     *
     * @param argument the argument to be quoted
     * @return the quoted argument
     * @throws IllegalArgumentException If argument contains both types of quotes
     */
    public static String quoteArgument(final String argument) {

        String cleanedArgument = argument.trim();

        // strip the quotes from both ends
        while(cleanedArgument.startsWith(SINGLE_QUOTE) || cleanedArgument.startsWith(DOUBLE_QUOTE)) {
            cleanedArgument = cleanedArgument.substring(1);
        }
        
        while(cleanedArgument.endsWith(SINGLE_QUOTE) || cleanedArgument.endsWith(DOUBLE_QUOTE)) {
            cleanedArgument = cleanedArgument.substring(0, cleanedArgument.length() - 1);
        }

        final StringBuffer buf = new StringBuffer();
        if (cleanedArgument.indexOf(DOUBLE_QUOTE) > -1) {
            if (cleanedArgument.indexOf(SINGLE_QUOTE) > -1) {
                throw new IllegalArgumentException(
                        "Can't handle single and double quotes in same argument");
            } else {
                return buf.append(SINGLE_QUOTE).append(cleanedArgument).append(
                        SINGLE_QUOTE).toString();
            }
        } else if (cleanedArgument.indexOf(SINGLE_QUOTE) > -1
                || cleanedArgument.indexOf(" ") > -1) {
            return buf.append(DOUBLE_QUOTE).append(cleanedArgument).append(
                    DOUBLE_QUOTE).toString();
        } else {
            return cleanedArgument;
        }
    }
    
    public static int calcLevenshteinDistance(String str1, String str2) {                          
        int len0 = str1.length() + 1;                                                     
        int len1 = str2.length() + 1;                                                     
     
        // the array of distances                                                       
        int[] cost = new int[len0];                                                     
        int[] newcost = new int[len0];                                                  
     
        // initial cost of skipping prefix in String s0                                 
        for (int i = 0; i < len0; i++) cost[i] = i;                                     
     
        // dynamically computing the array of distances                                  
     
        // transformation cost for each letter in s1                                    
        for (int j = 1; j < len1; j++) {                                                
            // initial cost of skipping prefix in String s1                             
            newcost[0] = j;                                                             
     
            // transformation cost for each letter in s0                                
            for(int i = 1; i < len0; i++) {                                             
                // matching current letters in both strings                             
                int match = (str1.charAt(i - 1) == str2.charAt(j - 1)) ? 0 : 1;             
     
                // computing cost for each transformation                               
                int cost_replace = cost[i - 1] + match;                                 
                int cost_insert  = cost[i] + 1;                                         
                int cost_delete  = newcost[i - 1] + 1;                                  
     
                // keep minimum cost                                                    
                newcost[i] = Math.min(Math.min(cost_insert, cost_delete), cost_replace);
            }                                                                           
     
            // swap cost/newcost arrays                                                 
            int[] swap = cost; cost = newcost; newcost = swap;                          
        }                                                                               
     
        // the distance is the cost for transforming all letters in both strings        
        return cost[len0 - 1];                                                          
    }

    /**
     * Split specified string with specified separator and trim the result fields. 
     * 
     * @param string 
     * @param separator
     * @return 
     * 			modifiable collection of split fields. Leading and trailing white spaces will be trimmed 
     * 			from these fields. Element of the resulting collection will never be null or 
     * 			empty string
     */
	public static List<String> splitAndTrim(@Nullable String string, String separator) {
		List<String> fields = new ArrayList<String>();
		if (string != null) {
			for (String each: StringUtils.split(string, separator)) {
				if (each != null && each.trim().length() != 0)
					fields.add(each.trim());
			}
		}
		return fields;
	}
	
	/**
	 * Split specified string with comma and line separator.
	 * 
	 * @param string
	 * 			string to be split
	 * @return
	 * 			modifiable collection of split fields. Leading and trailing white spaces will be trimmed
	 * 			from these fields. Element of resulting collection will never be null or empty string
	 */
	public static List<String> splitAndTrim(@Nullable String string) {
		return splitAndTrim(string, ",\n");
	}
	
	public static String escape(String string, String charsToEscape) {
		if (!charsToEscape.contains("\\"))
			charsToEscape += "\\";
		List<String> search = new ArrayList<>();
		List<String> replaceWith = new ArrayList<>();
		for (char ch: charsToEscape.toCharArray()) {
			search.add(String.valueOf(ch));
			replaceWith.add("\\" + String.valueOf(ch));
		}
		return replaceEach(
				string, 
				search.toArray(new String[search.size()]), 
				replaceWith.toArray(new String[replaceWith.size()]));
	}
	
	public static String unescape(String string) {
		return ESCAPE_PATTERN.matcher(string).replaceAll("$1");
	}
	
	public static List<String> splitToLines(String string) {
		if (string.contains("\r\n"))
			return Splitter.on("\r\n").splitToList(string);
		else
			return Splitter.on('\n').splitToList(string);
	}
	
}
